name: Deploy

on:
  push:
    branches:
      - develop
      - master
      - prod

env:
  PROJECT_ID: ${{ secrets.PROJECT_ID }}
  RUN_REGION: us-central1
  REPO_NAME: ${{ github.event.repository.name }}
  ARTIFACT_REGISTRY_REPO_NAME: ashes
  # Resource configuration (optimized for I/O-bound TTS operations)
  # Increased CPU for better parallelism, reduced memory for cost efficiency
  CPU_COUNT: 2
  MEMORY_LIMIT: 8Gi
  MIN_INSTANCES: 1  # Keep warm to avoid Redis startup latency
  MAX_INSTANCES: 1  # Increased for better burst handling
  CONCURRENCY: 2   # Inc∆íCreased for better throughput
  REQUEST_TIMEOUT: 120s  # Reduced timeout (TTS operations are fast)

jobs:
  lint:
      name: Linting and Quality Checks
      runs-on: ubuntu-latest

      steps:
        - name: Checkout the code
          uses: actions/checkout@v3

        - name: Set up Python
          uses: actions/setup-python@v4
          with:
            python-version: '3.12'  # Match Dockerfile

        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install flake8 black pylint
            pip install umsgpack
            pip install pylint-fail-under

        - name: Lint with flake8 (syntax errors)
          run: |
            # Stop the build if there are Python syntax errors or undefined names
            flake8 app tests --count --select=E9,F63,F7,F82 --show-source --statistics

        - name: Lint with flake8 (warnings)
          run: |
            # Exit-zero treats all errors as warnings
            flake8 app tests --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

        - name: Check formatting with black
          run: |
            black --check app tests

        - name: Code review (pylint - optional)
          run: find . -name '*.py' -print -exec pylint {} \; || true

        - name: Analyze code (pylint - optional)
          run: |
            for file in */*.py; do
              pylint "$file" --fail-under=0.0 || true
            done

  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: lint  # Run after linting passes

    steps:
      - name: Checkout the code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'  # Match Dockerfile

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[test]"

      - name: Generate .env file from secrets for integration tests
        shell: bash
        run: |
          echo "üìã Creating .env file for integration tests..."

          # Check if ENV_FILE secret exists
          if [ -z "${{ secrets.ENV_FILE }}" ]; then
            echo "‚ùå ENV_FILE secret not found or empty"
            echo "Integration tests will be skipped"
            echo "SKIP_INTEGRATION_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi

          # Decode base64-encoded ENV_FILE secret
          echo "${{ secrets.ENV_FILE }}" | tr -d '\n\r' | base64 --decode > .env 2>&1
          DECODE_STATUS=$?

          if [ $DECODE_STATUS -ne 0 ]; then
            echo "‚ùå Failed to decode ENV_FILE secret (exit code: $DECODE_STATUS)"
            echo "Integration tests will be skipped"
            echo "SKIP_INTEGRATION_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi

          # Verify .env exists and has content
          if [ ! -f .env ] || [ ! -s .env ]; then
            echo "‚ùå .env file is empty or missing"
            echo "Integration tests will be skipped"
            echo "SKIP_INTEGRATION_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi

          echo "‚úÖ .env file created successfully for integration tests"
          echo "SKIP_INTEGRATION_TESTS=false" >> $GITHUB_ENV

      - name: Run unit tests
        run: |
          echo "üß™ Running unit tests..."
          python -m pytest tests/unit/ -v -m "not redis" --tb=short --no-cov

      - name: Run integration tests (if environment available)
        if: env.SKIP_INTEGRATION_TESTS == 'false'
        run: |
          echo "üß™ Running integration tests..."

          # Validate .env file format before sourcing
          echo "üîç Validating .env file format..."
          LINE_NUM=0
          while IFS= read -r line || [ -n "$line" ]; do
            LINE_NUM=$((LINE_NUM + 1))
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            # Check if line has = sign (required for env vars)
            if [[ ! "$line" =~ = ]]; then
              echo "‚ùå ERROR: Line $LINE_NUM in .env is invalid (missing = sign):"
              echo "   $line"
              echo "   All non-comment lines must be in format: KEY=value"
              exit 1
            fi
            # Check for spaces around = (can cause issues)
            if [[ "$line" =~ [[:space:]]=[[:space:]] ]]; then
              echo "‚ö†Ô∏è  WARNING: Line $LINE_NUM has spaces around = sign (may cause issues):"
              echo "   $line"
            fi
          done < .env
          echo "‚úÖ .env file format validation passed"

          # Export all variables from .env file for integration tests
          # Use a safer method that handles .env file format correctly
          set -a
          # Filter out comments and empty lines, then export each variable
          while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            # Only process lines with = sign
            if [[ "$line" =~ = ]]; then
              # Normalize the line: remove spaces around = and trim
              # Split on = and trim both key and value
              key="${line%%=*}"
              value="${line#*=}"
              # Trim whitespace from key and value
              key=$(echo "$key" | xargs)
              value=$(echo "$value" | xargs)
              # Remove quotes from value if present
              value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
              # Export the normalized variable
              export "${key}=${value}"
            fi
          done < .env
          set +a

          python -m pytest tests/integration/ --run-integration -v --tb=short --no-cov

      - name: Run integration tests (skip if no environment)
        if: env.SKIP_INTEGRATION_TESTS == 'true'
        run: |
          echo "‚è≠Ô∏è Skipping integration tests (no environment variables available)"
          echo "This is expected if ENV_FILE secret is not configured"

      - name: Test summary
        if: always()
        run: |
          echo "=================================================="
          echo "  Test Summary"
          echo "=================================================="
          echo "Unit tests: ‚úÖ Completed"
          if [ "$SKIP_INTEGRATION_TESTS" = "false" ]; then
            echo "Integration tests: ‚úÖ Completed"
          else
            echo "Integration tests: ‚è≠Ô∏è Skipped (no env vars)"
          fi
          echo "=================================================="

  setup-build-deploy:
    name: Setup, Build, and Deploy
    runs-on: ubuntu-latest
    needs: [lint, test]  # Run after both linting and tests pass

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Verify tests passed
        run: |
          echo "‚úÖ All tests passed - proceeding with deployment"
          echo "This deployment is based on code that has passed:"
          echo "  - Linting and code quality checks"
          echo "  - Unit tests"
          echo "  - Integration tests (if environment available)"
          echo ""

      - name: Extract branch name and set service name
        shell: bash
        id: extract_branch
        run: |
          BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/})
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_ENV

          # Use different service names per branch or single service name
          if [ "$BRANCH_NAME" = "master" ] || [ "$BRANCH_NAME" = "prod" ]; then
            echo "SERVICE_NAME=master-hermes-backend" >> $GITHUB_ENV
          else
            echo "SERVICE_NAME=${BRANCH_NAME}-hermes-backend" >> $GITHUB_ENV
          fi

      - name: Print deployment info
        run: |
          echo "Branch: ${{ env.BRANCH_NAME }}"
          echo "Service: ${{ env.SERVICE_NAME }}"
          echo "Region: ${{ env.RUN_REGION }}"
          echo "Project: ${{ env.PROJECT_ID }}"

      - name: Generate .env file from secrets
        shell: bash
        run: |
          echo "üìã Creating .env file from GitHub secrets..."

          # Check if ENV_FILE secret exists
          if [ -z "${{ secrets.ENV_FILE }}" ]; then
            echo "‚ùå ENV_FILE secret not found or empty"
            echo ""
            echo "To fix this, create the ENV_FILE secret:"
            echo "1. Encode your .env file: cat .env | base64 -w 0"
            echo "2. Go to: Repository ‚Üí Settings ‚Üí Secrets ‚Üí Actions"
            echo "3. Create secret named: ENV_FILE"
            echo "4. Paste the base64 output as the value"
            exit 1
          fi

          # Decode base64-encoded ENV_FILE secret
          # Strip whitespace/newlines and decode
          echo "${{ secrets.ENV_FILE }}" | tr -d '\n\r' | base64 --decode > .env 2>&1
          DECODE_STATUS=$?

          if [ $DECODE_STATUS -ne 0 ]; then
            echo "‚ùå Failed to decode ENV_FILE secret (exit code: $DECODE_STATUS)"
            echo ""
            echo "The ENV_FILE secret appears to be invalid base64."
            echo ""
            echo "To fix this:"
            echo "1. On macOS/Linux: cat .env | base64 -w 0 | pbcopy"
            echo "2. On Linux (no pbcopy): cat .env | base64 -w 0"
            echo "3. Update GitHub secret ENV_FILE with the output"
            echo ""
            echo "Make sure to use 'base64 -w 0' to avoid newlines!"
            exit 1
          fi

          # Verify .env exists and has content
          if [ ! -f .env ]; then
            echo "‚ùå .env file was not created"
            exit 1
          fi

          if [ ! -s .env ]; then
            echo "‚ùå .env file is empty"
            exit 1
          fi

          echo "‚úÖ .env file created successfully"
          echo "‚úÖ File size: $(wc -c < .env) bytes"
          echo "‚úÖ Number of lines: $(wc -l < .env)"
          echo ""
          echo "Environment variables found:"
          grep -o '^[^=]*' .env | grep -v '^#' | grep -v '^$' | head -10

      - name: Authenticate with Google Cloud
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.SA_KEY_JSON }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Verify gcloud authentication
        run: |
          gcloud info
          gcloud config get-value project

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.RUN_REGION }}-docker.pkg.dev --quiet

      - name: Build and push image to Artifact Registry
        run: |
          echo "üî® Building Docker image..."

          IMAGE_NAME="${{ env.RUN_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO_NAME }}/${{ env.SERVICE_NAME }}"
          # Get first 8 characters of commit SHA
          BUILD_TAG="$(echo '${{ github.sha }}' | cut -c1-8)"

          echo "Image: ${IMAGE_NAME}:${BUILD_TAG}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Build Tag: ${BUILD_TAG}"
          echo ""

          # Build and push with commit SHA tag
          echo "Building with Cloud Build..."
          gcloud builds submit \
            --tag "${IMAGE_NAME}:${BUILD_TAG}" \
            --project=${{ env.PROJECT_ID }} \
            --timeout=20m

          BUILD_STATUS=$?
          if [ $BUILD_STATUS -ne 0 ]; then
            echo "‚ùå Cloud Build failed with exit code: $BUILD_STATUS"
            exit 1
          fi

          echo "‚úÖ Image built: ${IMAGE_NAME}:${BUILD_TAG}"

          # Tag the image with 'latest' as well
          echo "Tagging image as :latest..."
          gcloud artifacts docker tags add \
            "${IMAGE_NAME}:${BUILD_TAG}" \
            "${IMAGE_NAME}:latest" \
            --project=${{ env.PROJECT_ID }}

          echo "‚úÖ Image tagged: ${IMAGE_NAME}:latest"
          echo ""
          echo "‚úÖ Docker image built and pushed successfully"

          # Export for use in later steps
          echo "IMAGE_NAME=${IMAGE_NAME}" >> $GITHUB_ENV
          echo "BUILD_TAG=${BUILD_TAG}" >> $GITHUB_ENV

      - name: Verify image exists in Artifact Registry
        run: |
          echo "üîç Verifying image exists in Artifact Registry..."

          # Check if image exists
          if gcloud artifacts docker images describe \
            "${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}" \
            --project=${{ env.PROJECT_ID }} > /dev/null 2>&1; then
            echo "‚úÖ Image verified: ${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}"
          else
            echo "‚ùå ERROR: Image not found in Artifact Registry"
            echo "Expected: ${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}"
            echo ""
            echo "Listing available images:"
            gcloud artifacts docker images list \
              "${{ env.IMAGE_NAME }}" \
              --project=${{ env.PROJECT_ID }} || true
            exit 1
          fi

          echo ""

      - name: Prepare environment variables for Cloud Run
        run: |
          echo "üìã Preparing environment variables YAML file..."

          # Create YAML file with base env vars
          cat > env.yaml << 'EOF'
          PROJECT_ID: "${{ env.PROJECT_ID }}"
          SERVICE_NAME: "${{ env.SERVICE_NAME }}"
          REGION_DEPLOYED: "${{ env.RUN_REGION }}"
          APPLICATION_ENV: "production"
          APP_NAME: "hermes-backend"
          SA_KEY_JSON: "${{ secrets.SA_KEY_JSON }}"
          EOF

          # Parse .env and append to YAML (matches deploy.sh logic)
          # Note: All environment variables from .env are included automatically,
          # including Langfuse variables (LANGFUSE_SECRET_KEY, LANGFUSE_PUBLIC_KEY, LANGFUSE_BASE_URL)
          while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^#.*$ ]] && continue
            [[ -z "$key" ]] && continue

            # Skip keys that shouldn't be in Cloud Run
            case "$key" in
              GOOGLE_APPLICATION_CREDENTIALS|TTS_DEVICE|REDIS_URL|PORT)
                continue
                ;;
            esac

            # Remove quotes from value
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")

            # Add to environment variables YAML file
            # Use literal block style for prompts (multi-line text), quoted strings for everything else
            if [[ "$key" =~ _PROMPT$ ]] || [[ "$key" == "BASE_PROMPT" ]]; then
              echo "${key}: |-" >> env.yaml
              echo "  ${value}" >> env.yaml
            else
              escaped_value=$(printf '%s' "$value" | sed 's/"/\\"/g')
              echo "${key}: \"${escaped_value}\"" >> env.yaml
            fi

            echo "   ‚úì ${key}"
          done < .env

          echo "‚úÖ Environment variables YAML file created"
          echo ""
          echo "üìã Environment variables being deployed:"
          echo "Keys loaded from .env:"
          grep -o '^[A-Z_]*:' env.yaml | sed 's/://' | sort
          echo ""
          echo "Checking for excluded keys:"
          if grep -q "GOOGLE_APPLICATION_CREDENTIALS" env.yaml; then
            echo "‚ùå ERROR: GOOGLE_APPLICATION_CREDENTIALS found in env.yaml (should be excluded!)"
            exit 1
          else
            echo "‚úÖ GOOGLE_APPLICATION_CREDENTIALS correctly excluded"
          fi

      - name: Deploy to Cloud Run
        run: |
          echo "üöÄ Deploying to Cloud Run..."

          gcloud run deploy "${{ env.SERVICE_NAME }}" \
            --quiet \
            --region "${{ env.RUN_REGION }}" \
            --image "${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}" \
            --platform managed \
            --execution-environment gen2 \
            --cpu ${{ env.CPU_COUNT }} \
            --memory ${{ env.MEMORY_LIMIT }} \
            --no-cpu-throttling \
            --min-instances ${{ env.MIN_INSTANCES }} \
            --max-instances ${{ env.MAX_INSTANCES }} \
            --concurrency ${{ env.CONCURRENCY }} \
            --timeout ${{ env.REQUEST_TIMEOUT }} \
            --cpu-boost \
            --allow-unauthenticated \
            --env-vars-file=env.yaml \
            --project=${{ env.PROJECT_ID }}

          echo "‚úÖ Deployment successful"

      - name: Configure webhook URLs
        run: |
          echo "üîß Configuring webhook URLs..."

          SERVICE_URL=$(gcloud run services describe "${{ env.SERVICE_NAME }}" \
            --platform managed \
            --region "${{ env.RUN_REGION }}" \
            --format 'value(status.url)' \
            --project=${{ env.PROJECT_ID }})

          if [ -n "$SERVICE_URL" ]; then
            echo "Service URL: $SERVICE_URL"

            WEBSOCKET_URL=$(echo "$SERVICE_URL" | sed 's/https:/wss:/')

            # Check if WEBHOOK_BASE_URL is already set in .env
            if ! grep -q "^WEBHOOK_BASE_URL=" .env 2>/dev/null; then
              echo "Setting webhook URLs..."
              gcloud run services update "${{ env.SERVICE_NAME }}" \
                --region="${{ env.RUN_REGION }}" \
                --update-env-vars="WEBHOOK_BASE_URL=${SERVICE_URL},WEBSOCKET_BASE_URL=${WEBSOCKET_URL}" \
                --quiet \
                --project=${{ env.PROJECT_ID }}
              echo "‚úÖ Webhook URLs configured"
            else
              echo "‚úÖ Webhook URLs already set in .env"
            fi
          else
            echo "‚ö†Ô∏è  Could not retrieve service URL"
          fi

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."

          SERVICE_URL=$(gcloud run services describe "${{ env.SERVICE_NAME }}" \
            --platform managed \
            --region "${{ env.RUN_REGION }}" \
            --format 'value(status.url)' \
            --project=${{ env.PROJECT_ID }})

          if [ -z "$SERVICE_URL" ]; then
            echo "‚ùå Could not retrieve service URL"
            exit 1
          fi

          echo "‚úÖ Service URL: $SERVICE_URL"

          # Wait for service to be ready
          echo "Waiting for service to be ready..."
          sleep 10

          # Test health endpoint
          echo "Testing /health endpoint..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${SERVICE_URL}/health" || echo "000")

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Health check passed (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è  Health check returned HTTP $HTTP_CODE"
            echo "Service may still be starting up"

            # Show recent logs
            echo "Recent logs:"
            gcloud run services logs read "${{ env.SERVICE_NAME }}" \
              --region="${{ env.RUN_REGION }}" \
              --limit=20 \
              --project=${{ env.PROJECT_ID }} || true
          fi

      - name: Deployment summary
        if: always()
        run: |
          echo "=================================================="
          echo "  Deployment Summary"
          echo "=================================================="
          echo "Service:    ${{ env.SERVICE_NAME }}"
          echo "Region:     ${{ env.RUN_REGION }}"
          echo "Image:      ${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}"
          echo "Branch:     ${{ env.BRANCH_NAME }}"
          echo "Commit:     ${{ github.sha }}"
          echo "Resources:  ${{ env.CPU_COUNT }} CPU, ${{ env.MEMORY_LIMIT }} RAM"
          echo "Scaling:    ${{ env.MIN_INSTANCES }}-${{ env.MAX_INSTANCES }} instances"
          echo "=================================================="
