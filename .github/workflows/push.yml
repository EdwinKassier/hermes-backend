name: Deploy

on:
  push:
    branches:
      - develop
      - master
      - prod

env:
  PROJECT_ID: ${{ secrets.PROJECT_ID }}
  RUN_REGION: us-central1
  REPO_NAME: ${{ github.event.repository.name }}
  ARTIFACT_REGISTRY_REPO_NAME: ashes
  # Resource configuration (matches deploy.sh)
  # Increased for local Redis + 8 Gunicorn workers + AI operations
  CPU_COUNT: 2
  MEMORY_LIMIT: 6Gi
  MIN_INSTANCES: 1  # Keep warm to avoid Redis startup latency
  MAX_INSTANCES: 10
  CONCURRENCY: 50
  REQUEST_TIMEOUT: 300s

jobs:
  lint:
      name: Linting and Quality Checks
      runs-on: ubuntu-latest

      steps:
        - name: Checkout the code
          uses: actions/checkout@v3
        
        - name: Set up Python
          uses: actions/setup-python@v4
          with:
            python-version: '3.12'  # Match Dockerfile
        
        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install pylint
            pip install umsgpack
            pip install pylint-fail-under
        
        - name: Code review
          run: find . -name '*.py' -print -exec pylint {} \; || true
        
        - name: Analyze code
          run: |
            for file in */*.py; do 
              pylint "$file" --fail-under=0.0 || true
            done

  setup-build-deploy:
    name: Setup, Build, and Deploy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Extract branch name and set service name
        shell: bash
        id: extract_branch
        run: |
          BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/})
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_ENV
          
          # Use different service names per branch or single service name
          if [ "$BRANCH_NAME" = "master" ] || [ "$BRANCH_NAME" = "prod" ]; then
            echo "SERVICE_NAME=master-hermes-backend" >> $GITHUB_ENV
          else
            echo "SERVICE_NAME=${BRANCH_NAME}-hermes-backend" >> $GITHUB_ENV
          fi

      - name: Print deployment info
        run: |
          echo "Branch: ${{ env.BRANCH_NAME }}"
          echo "Service: ${{ env.SERVICE_NAME }}"
          echo "Region: ${{ env.RUN_REGION }}"
          echo "Project: ${{ env.PROJECT_ID }}"

      - name: Generate .env file from secrets
        shell: bash
        run: |
          echo "üìã Creating .env file from GitHub secrets..."
          
          # Check if ENV_FILE secret exists
          if [ -z "${{ secrets.ENV_FILE }}" ]; then
            echo "‚ùå ENV_FILE secret not found or empty"
            echo ""
            echo "To fix this, create the ENV_FILE secret:"
            echo "1. Encode your .env file: cat .env | base64 -w 0"
            echo "2. Go to: Repository ‚Üí Settings ‚Üí Secrets ‚Üí Actions"
            echo "3. Create secret named: ENV_FILE"
            echo "4. Paste the base64 output as the value"
            exit 1
          fi
          
          # Decode base64-encoded ENV_FILE secret
          # Strip whitespace/newlines and decode
          echo "${{ secrets.ENV_FILE }}" | tr -d '\n\r' | base64 --decode > .env 2>&1
          DECODE_STATUS=$?
          
          if [ $DECODE_STATUS -ne 0 ]; then
            echo "‚ùå Failed to decode ENV_FILE secret (exit code: $DECODE_STATUS)"
            echo ""
            echo "The ENV_FILE secret appears to be invalid base64."
            echo ""
            echo "To fix this:"
            echo "1. On macOS/Linux: cat .env | base64 -w 0 | pbcopy"
            echo "2. On Linux (no pbcopy): cat .env | base64 -w 0"
            echo "3. Update GitHub secret ENV_FILE with the output"
            echo ""
            echo "Make sure to use 'base64 -w 0' to avoid newlines!"
            exit 1
          fi
          
          # Verify .env exists and has content
          if [ ! -f .env ]; then
            echo "‚ùå .env file was not created"
            exit 1
          fi
          
          if [ ! -s .env ]; then
            echo "‚ùå .env file is empty"
            exit 1
          fi
          
          echo "‚úÖ .env file created successfully"
          echo "‚úÖ File size: $(wc -c < .env) bytes"
          echo "‚úÖ Number of lines: $(wc -l < .env)"
          echo ""
          echo "Environment variables found:"
          grep -o '^[^=]*' .env | grep -v '^#' | grep -v '^$' | head -10

      - name: Authenticate with Google Cloud
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.SA_KEY_JSON }}'

      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v2'
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Verify gcloud authentication
        run: |
          gcloud info
          gcloud config get-value project

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.RUN_REGION }}-docker.pkg.dev --quiet

      - name: Build and push image to Artifact Registry
        run: |
          echo "üî® Building Docker image..."
          
          IMAGE_NAME="${{ env.RUN_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY_REPO_NAME }}/${{ env.SERVICE_NAME }}"
          # Get first 8 characters of commit SHA
          BUILD_TAG="$(echo '${{ github.sha }}' | cut -c1-8)"
          
          echo "Image: ${IMAGE_NAME}:${BUILD_TAG}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Build Tag: ${BUILD_TAG}"
          echo ""
          
          # Build and push with commit SHA tag
          echo "Building with Cloud Build..."
          gcloud builds submit \
            --tag "${IMAGE_NAME}:${BUILD_TAG}" \
            --project=${{ env.PROJECT_ID }} \
            --timeout=20m
          
          BUILD_STATUS=$?
          if [ $BUILD_STATUS -ne 0 ]; then
            echo "‚ùå Cloud Build failed with exit code: $BUILD_STATUS"
            exit 1
          fi
          
          echo "‚úÖ Image built: ${IMAGE_NAME}:${BUILD_TAG}"
          
          # Tag the image with 'latest' as well
          echo "Tagging image as :latest..."
          gcloud artifacts docker tags add \
            "${IMAGE_NAME}:${BUILD_TAG}" \
            "${IMAGE_NAME}:latest" \
            --project=${{ env.PROJECT_ID }}
          
          echo "‚úÖ Image tagged: ${IMAGE_NAME}:latest"
          echo ""
          echo "‚úÖ Docker image built and pushed successfully"
          
          # Export for use in later steps
          echo "IMAGE_NAME=${IMAGE_NAME}" >> $GITHUB_ENV
          echo "BUILD_TAG=${BUILD_TAG}" >> $GITHUB_ENV

      - name: Verify image exists in Artifact Registry
        run: |
          echo "üîç Verifying image exists in Artifact Registry..."
          
          # Check if image exists
          if gcloud artifacts docker images describe \
            "${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}" \
            --project=${{ env.PROJECT_ID }} > /dev/null 2>&1; then
            echo "‚úÖ Image verified: ${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}"
          else
            echo "‚ùå ERROR: Image not found in Artifact Registry"
            echo "Expected: ${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}"
            echo ""
            echo "Listing available images:"
            gcloud artifacts docker images list \
              "${{ env.IMAGE_NAME }}" \
              --project=${{ env.PROJECT_ID }} || true
            exit 1
          fi
          
          echo ""

      - name: Prepare environment variables for Cloud Run
        run: |
          echo "üìã Preparing environment variables YAML file..."
          
          # Create YAML file with base env vars
          cat > env.yaml << 'EOF'
          PROJECT_ID: "${{ env.PROJECT_ID }}"
          SERVICE_NAME: "${{ env.SERVICE_NAME }}"
          REGION_DEPLOYED: "${{ env.RUN_REGION }}"
          APPLICATION_ENV: "production"
          APP_NAME: "hermes-backend"
          EOF
          
          # Parse .env and append to YAML (matches deploy.sh logic)
          while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^#.*$ ]] && continue
            [[ -z "$key" ]] && continue
            
            # Skip keys that shouldn't be in Cloud Run
            case "$key" in
              GOOGLE_APPLICATION_CREDENTIALS|TTS_DEVICE|REDIS_URL|PORT)
                continue
                ;;
            esac
            
            # Remove quotes from value
            value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
            
            # Add to environment variables YAML file
            # Use literal block style for prompts (multi-line text), quoted strings for everything else
            if [[ "$key" =~ _PROMPT$ ]] || [[ "$key" == "BASE_PROMPT" ]]; then
              echo "${key}: |-" >> env.yaml
              echo "  ${value}" >> env.yaml
            else
              escaped_value=$(printf '%s' "$value" | sed 's/"/\\"/g')
              echo "${key}: \"${escaped_value}\"" >> env.yaml
            fi
            
            echo "   ‚úì ${key}"
          done < .env
          
          echo "‚úÖ Environment variables YAML file created"
          echo ""
          echo "üìã Environment variables being deployed:"
          echo "Keys loaded from .env:"
          grep -o '^[A-Z_]*:' env.yaml | sed 's/://' | sort
          echo ""
          echo "Checking for excluded keys:"
          if grep -q "GOOGLE_APPLICATION_CREDENTIALS" env.yaml; then
            echo "‚ùå ERROR: GOOGLE_APPLICATION_CREDENTIALS found in env.yaml (should be excluded!)"
            exit 1
          else
            echo "‚úÖ GOOGLE_APPLICATION_CREDENTIALS correctly excluded"
          fi

      - name: Deploy to Cloud Run
        run: |
          echo "üöÄ Deploying to Cloud Run..."
          
          gcloud run deploy "${{ env.SERVICE_NAME }}" \
            --quiet \
            --region "${{ env.RUN_REGION }}" \
            --image "${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}" \
            --platform managed \
            --execution-environment gen2 \
            --cpu ${{ env.CPU_COUNT }} \
            --memory ${{ env.MEMORY_LIMIT }} \
            --no-cpu-throttling \
            --min-instances ${{ env.MIN_INSTANCES }} \
            --max-instances ${{ env.MAX_INSTANCES }} \
            --concurrency ${{ env.CONCURRENCY }} \
            --timeout ${{ env.REQUEST_TIMEOUT }} \
            --cpu-boost \
            --allow-unauthenticated \
            --env-vars-file=env.yaml \
            --project=${{ env.PROJECT_ID }}
          
          echo "‚úÖ Deployment successful"

      - name: Configure webhook URLs
        run: |
          echo "üîß Configuring webhook URLs..."
          
          SERVICE_URL=$(gcloud run services describe "${{ env.SERVICE_NAME }}" \
            --platform managed \
            --region "${{ env.RUN_REGION }}" \
            --format 'value(status.url)' \
            --project=${{ env.PROJECT_ID }})
          
          if [ -n "$SERVICE_URL" ]; then
            echo "Service URL: $SERVICE_URL"
            
            WEBSOCKET_URL=$(echo "$SERVICE_URL" | sed 's/https:/wss:/')
            
            # Check if WEBHOOK_BASE_URL is already set in .env
            if ! grep -q "^WEBHOOK_BASE_URL=" .env 2>/dev/null; then
              echo "Setting webhook URLs..."
              gcloud run services update "${{ env.SERVICE_NAME }}" \
                --region="${{ env.RUN_REGION }}" \
                --update-env-vars="WEBHOOK_BASE_URL=${SERVICE_URL},WEBSOCKET_BASE_URL=${WEBSOCKET_URL}" \
                --quiet \
                --project=${{ env.PROJECT_ID }}
              echo "‚úÖ Webhook URLs configured"
            else
              echo "‚úÖ Webhook URLs already set in .env"
            fi
          else
            echo "‚ö†Ô∏è  Could not retrieve service URL"
          fi

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          SERVICE_URL=$(gcloud run services describe "${{ env.SERVICE_NAME }}" \
            --platform managed \
            --region "${{ env.RUN_REGION }}" \
            --format 'value(status.url)' \
            --project=${{ env.PROJECT_ID }})
          
          if [ -z "$SERVICE_URL" ]; then
            echo "‚ùå Could not retrieve service URL"
            exit 1
          fi
          
          echo "‚úÖ Service URL: $SERVICE_URL"
          
          # Wait for service to be ready
          echo "Waiting for service to be ready..."
          sleep 10
          
          # Test health endpoint
          echo "Testing /health endpoint..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${SERVICE_URL}/health" || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Health check passed (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è  Health check returned HTTP $HTTP_CODE"
            echo "Service may still be starting up"
            
            # Show recent logs
            echo "Recent logs:"
            gcloud run services logs read "${{ env.SERVICE_NAME }}" \
              --region="${{ env.RUN_REGION }}" \
              --limit=20 \
              --project=${{ env.PROJECT_ID }} || true
          fi

      - name: Deployment summary
        if: always()
        run: |
          echo "=================================================="
          echo "  Deployment Summary"
          echo "=================================================="
          echo "Service:    ${{ env.SERVICE_NAME }}"
          echo "Region:     ${{ env.RUN_REGION }}"
          echo "Image:      ${{ env.IMAGE_NAME }}:${{ env.BUILD_TAG }}"
          echo "Branch:     ${{ env.BRANCH_NAME }}"
          echo "Commit:     ${{ github.sha }}"
          echo "Resources:  ${{ env.CPU_COUNT }} CPU, ${{ env.MEMORY_LIMIT }} RAM"
          echo "Scaling:    ${{ env.MIN_INSTANCES }}-${{ env.MAX_INSTANCES }} instances"
          echo "=================================================="
